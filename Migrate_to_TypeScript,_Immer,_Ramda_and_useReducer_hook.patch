Index: src/Automaton.js
===================================================================
diff --git a/src/Automaton.js b/src/Automaton.js
deleted file mode 100644
--- a/src/Automaton.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ /dev/null	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
@@ -1,9 +0,0 @@
-class Automaton {
-  constructor() {
-    this.alphabet = [];
-    this.states = [];
-    this.transitionFunction = new Map();
-    this.initialState = null;
-    this.finalStates = [];
-  }
-}
Index: src/Input.js
===================================================================
diff --git a/src/Input.js b/src/Input.js
deleted file mode 100644
--- a/src/Input.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ /dev/null	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
@@ -1,442 +0,0 @@
-import React from 'react';
-import AlphabetInput from "./AlphabetInput";
-import StatesInput from "./StatesInput";
-import TransitionsInput from "./TransitionsInput";
-import {List, Map, OrderedSet} from "immutable";
-import {makeStyles} from "@material-ui/core/styles";
-import Button from "@material-ui/core/Button";
-import Typography from "@material-ui/core/Typography";
-import Step from "@material-ui/core/Step";
-import StepButton from "@material-ui/core/StepButton";
-import Stepper from "@material-ui/core/Stepper";
-import {useHistory} from "react-router-dom";
-import {StepLabel} from "@material-ui/core";
-import {NIL} from "uuid";
-
-const useStyles = makeStyles((theme) => ({
-  root: {
-    width: '100%',
-  },
-  button: {
-    marginRight: theme.spacing(1),
-  },
-  backButton: {
-    marginRight: theme.spacing(1),
-  },
-  completed: {
-    display: 'inline-block',
-  },
-  instructions: {
-    marginTop: theme.spacing(1),
-    marginBottom: theme.spacing(1),
-  },
-}));
-
-function createAutomaton(alphabet, states, initialStateIndex, finalStateIndices, transitions) {
-  const transitionsToTransitionFunction = transitions => {
-    let transitionFunction = Map();
-    for (const transition of transitions) {
-      const key = Map({
-        currentState: transition.get("currentState"),
-        symbol: transition.get("symbol"),
-      });
-      transitionFunction = transitionFunction.set(key, transition.get("nextStates"));
-    }
-    return transitionFunction;
-  }
-
-  return Map({
-    alphabet: alphabet,
-    states: OrderedSet(states),
-    transitionFunction: transitionsToTransitionFunction(transitions),
-    initialState: states.get(initialStateIndex),
-    finalStates: states.filter((value, index) => finalStateIndices.includes(index)),
-  })
-}
-
-export default function Input({addAutomaton, openSnackbar}) {
-  const classes = useStyles();
-
-  const history = useHistory();
-
-  const [alphabet, setAlphabet] = React.useState(OrderedSet());
-  const [alphabetPresetIndex, setAlphabetPresetIndex] = React.useState("");
-  const [states, setStates] = React.useState(List());
-  const [initialStateId, setInitialStateId] = React.useState(NIL);
-  const [finalStateIds, setFinalStateIds] = React.useState(OrderedSet());
-  const [transitions, setTransitions] = React.useState(List());
-
-  const stateIds = states.map(state => state.get("id"));
-  const findStateById = id => states.find(state => state.get("id") === id);
-
-  // Error checks to be performed
-  // Values may be a single boolean value or a List of boolean values, depending on the nature of the check
-  // For example, a check that is performed on the list of states will be a list of boolean values of the same length
-  // TODO: Currently `true` means valid which is counterintuitive; might change this
-  const errors = Map({
-    alphabet: Map({
-      isNonEmpty: !alphabet.isEmpty(),
-    }),
-    states: Map({
-      isNonEmpty: !states.isEmpty(),
-      areStateNamesNonEmpty: states.map(state => !!state.get("name")),
-      areStateNamesUnique: states.map(state1 =>
-        states.count(state2 => state2.get("name") === state1.get("name")) === 1
-      ),
-      exactlyOneInitialState: initialStateId !== NIL,
-    }),
-    transitions: Map({
-      areCurrentStatesNonEmpty: transitions.map(transition => transition.get("currentState") !== ""),
-      areCurrentStatesValid: transitions.map(transition => stateIds.includes(transition.get("currentState"))),
-      areSymbolsNonEmpty: transitions.map(transition => transition.get("symbol") !== ""),
-      areSymbolsValid: transitions.map(transition => alphabet.includes(transition.get("symbol"))),
-      areNextStatesNonEmpty: transitions.map(transition => !transition.get("nextStates").isEmpty()),
-      areNextStatesValid: transitions.map(transition => transition.get("nextStates").isSubset(stateIds)),
-      areTransitionsUnique: transitions.map(transition1 => transitions.count(transition2 =>
-        transition1.get("currentState") === transition2.get("currentState")
-        && transition1.get("symbol") === transition2.get("symbol")
-      ) === 1),
-    }),
-  });
-
-  // Warning checks to be performed
-  // Similar to `errors` but for warnings (issues where the input is still valid)
-  const warnings = Map({
-    states: Map({
-      atLeastOneFinalState: !finalStateIds.isEmpty(),
-    }),
-    transitions: Map({
-      isNonEmpty: !transitions.isEmpty(),
-    }),
-  });
-
-  // Messages for each of the error checks
-  const errorMessages = Map({
-    alphabet: Map({
-      isNonEmpty: "Alphabet cannot be empty",
-    }),
-    states: Map({
-      isNonEmpty: "At least one state is required",
-      areStateNamesNonEmpty: "State name cannot be left blank",
-      areStateNamesUnique: "State name must be unique",
-      exactlyOneInitialState: "A state must be selected as the initial state"
-    }),
-    transitions: Map({
-      areCurrentStatesNonEmpty: "Current state cannot be left blank",
-      areCurrentStatesValid: "State does not exist",
-      areSymbolsNonEmpty: "Symbol cannot be left blank",
-      areSymbolsValid: "Symbol does not exist in alphabet",
-      areNextStatesNonEmpty: "Next states cannot be empty",
-      areNextStatesValid: "One or more states do not exist",
-      areTransitionsUnique: "Transition must be unique",
-      statesIsNonEmpty: "There are no states",
-      alphabetIsNonEmpty: "Alphabet is empty",
-    }),
-  });
-
-  // Messages for each of the warning checks
-  const warningMessages = Map({
-    states: Map({
-      atLeastOneFinalState: "No state is selected as the final state, so all strings will be rejected by the automaton",
-    }),
-    transitions: Map({
-      isNonEmpty: states.isEmpty() || !stateIds.includes(initialStateId) ? "There are no transitions" : (
-        finalStateIds.includes(initialStateId)
-          ? `There are no transitions and initial state "${findStateById(initialStateId).get("name")}" is a final state, so all strings will be accepted by the automaton`
-          : `There are no transitions and initial state "${findStateById(initialStateId).get("name")}" is not a final state, so all strings will be rejected by the automaton`
-      ),
-    }),
-  });
-
-  const disabled = Map({
-    transitions: Map({
-      currentState: transitions.map(() => errors.getIn(["states", "isNonEmpty"])),
-      symbol: transitions.map(() => errors.getIn(["alphabet", "isNonEmpty"])),
-      nextStates: transitions.map(() => errors.getIn(["states", "isNonEmpty"])),
-    })
-  })
-
-  // For single boolean values, can compute error state by doing !(x1 && ... && xn) (each xi is a check)
-  // For lists, need to repeat this for each item in the lists
-  const createErrorStateList = (errors, disabled) => {
-    let l = errors[0];
-    for (let i = 1; i < errors.length; i++) {
-      l = l.zipWith((x, y) => x && y, errors[i]);
-    }
-    l = l.map(x => !x);
-
-    if (disabled) {
-      l = disabled.zipWith((x, y) => x && y, l);
-    }
-
-    return l;
-  }
-
-  // Error state for each input
-  // Some inputs may be associated with more than one check - e.g. check state name is non-empty AND unique
-  // Hence need to combine error checks into a boolean value for each input
-  // Could just check whether helper text is non-empty but may want to display helper text not for an error
-  const errorState = Map({
-    alphabet: Map({
-      alphabet: !errors.getIn(["alphabet", "isNonEmpty"]),
-    }),
-    states: Map({
-      stateName: createErrorStateList([
-        errors.getIn(["states", "areStateNamesNonEmpty"]),
-        errors.getIn(["states", "areStateNamesUnique"]),
-      ])
-    }),
-    transitions: Map({
-      currentState: createErrorStateList([
-        errors.getIn(["transitions", "areCurrentStatesNonEmpty"]),
-        errors.getIn(["transitions", "areCurrentStatesValid"]),
-        errors.getIn(["transitions", "areTransitionsUnique"]),
-      ], disabled.getIn(["transitions", "currentState"])),
-      symbol: createErrorStateList([
-        errors.getIn(["transitions", "areSymbolsNonEmpty"]),
-        errors.getIn(["transitions", "areSymbolsValid"]),
-        errors.getIn(["transitions", "areTransitionsUnique"]),
-      ], disabled.getIn(["transitions", "symbol"])),
-      nextStates: createErrorStateList([
-        errors.getIn(["transitions", "areNextStatesNonEmpty"]),
-        errors.getIn(["transitions", "areNextStatesValid"]),
-      ], disabled.getIn(["transitions", "nextStates"])),
-    }),
-  });
-
-  // Same idea as `createErrorStateList`
-  const createHelperTextList = (errors, errorMessages) => {
-    let l = errors[0].map(x => x || errorMessages[0]);
-    for (let i = 1; i < errors.length; i++) {
-      l = l.zipWith((x, y) => x === true ? y : x,
-        errors[i].map(y => y || errorMessages[i])
-      );
-    }
-    return l;
-  };
-
-  // Helper text for each input
-  // Same idea as `errorState`
-  const helperText = Map({
-    alphabet: Map({
-      alphabet: errors.getIn(["alphabet", "isNonEmpty"]) || errorMessages.getIn(["alphabet", "isNonEmpty"]),
-    }),
-    states: Map({
-      stateName: createHelperTextList([
-        errors.getIn(["states", "areStateNamesNonEmpty"]),
-        errors.getIn(["states", "areStateNamesUnique"]),
-      ], [
-        errorMessages.getIn(["states", "areStateNamesNonEmpty"]),
-        errorMessages.getIn(["states", "areStateNamesUnique"]),
-      ]),
-    }),
-    transitions: Map({
-      currentState: createHelperTextList([
-        disabled.getIn(["transitions", "currentState"]),
-        errors.getIn(["transitions", "areCurrentStatesNonEmpty"]),
-        errors.getIn(["transitions", "areCurrentStatesValid"]),
-        errors.getIn(["transitions", "areTransitionsUnique"]),
-      ], [
-        errorMessages.getIn(["transitions", "statesIsNonEmpty"]),
-        errorMessages.getIn(["transitions", "areCurrentStatesNonEmpty"]),
-        errorMessages.getIn(["transitions", "areCurrentStatesValid"]),
-        errorMessages.getIn(["transitions", "areTransitionsUnique"]),
-      ]),
-      symbol: createHelperTextList([
-        disabled.getIn(["transitions", "symbol"]),
-        errors.getIn(["transitions", "areSymbolsNonEmpty"]),
-        errors.getIn(["transitions", "areSymbolsValid"]),
-        errors.getIn(["transitions", "areTransitionsUnique"]),
-      ], [
-        errorMessages.getIn(["transitions", "alphabetIsNonEmpty"]),
-        errorMessages.getIn(["transitions", "areSymbolsNonEmpty"]),
-        errorMessages.getIn(["transitions", "areSymbolsValid"]),
-        errorMessages.getIn(["transitions", "areTransitionsUnique"]),
-      ]),
-      nextStates: createHelperTextList([
-        disabled.getIn(["transitions", "nextStates"]),
-        errors.getIn(["transitions", "areNextStatesNonEmpty"]),
-        errors.getIn(["transitions", "areNextStatesValid"]),
-      ], [
-        errorMessages.getIn(["transitions", "statesIsNonEmpty"]),
-        errorMessages.getIn(["transitions", "areNextStatesNonEmpty"]),
-        errorMessages.getIn(["transitions", "areNextStatesValid"]),
-      ]),
-    }),
-  });
-
-  // List of error messages to display in an alert
-  // Some errors can't be associated with an input - e.g. states or transitions list being empty
-  // Hence these are displayed in an alert
-  const errorAlertText = Map({
-    states: List([
-      errors.getIn(["states", "isNonEmpty"]) || errorMessages.getIn(["states", "isNonEmpty"]),
-      !errors.getIn(["states", "isNonEmpty"]) || errors.getIn(["states", "exactlyOneInitialState"]) || errorMessages.getIn(["states", "exactlyOneInitialState"]),
-    ]),
-  }).map(x => x.filterNot(y => y === true)); // Remove `true` values, thus keeping only the strings
-
-  // List of warning messages to display in an alert
-  const warningAlertText = Map({
-    states: List([
-      !errors.getIn(["states", "isNonEmpty"]) || warnings.getIn(["states", "atLeastOneFinalState"]) || warningMessages.getIn(["states", "atLeastOneFinalState"]),
-    ]),
-    transitions: List([
-      !errors.getIn(["states", "exactlyOneInitialState"]) || !warnings.getIn(["states", "atLeastOneFinalState"]) || warnings.getIn(["transitions", "isNonEmpty"]) || warningMessages.getIn(["transitions", "isNonEmpty"]),
-    ]),
-  }).map(x => x.filterNot(y => y === true));
-
-  const fixInitialStateId = () => {
-    setInitialStateId(prevInitialStateId => stateIds.includes(prevInitialStateId) ? prevInitialStateId : NIL);
-  };
-
-  const fixFinalStateIds = () => {
-    setFinalStateIds(prevFinalStateIds => prevFinalStateIds.intersect(stateIds));
-  };
-
-  const fixTransitionCurrentStates = () => {
-    setTransitions(prevTransitions => prevTransitions.map(transition =>
-      transition.update("currentState", currentState => stateIds.includes(currentState) ? currentState : "")
-    ));
-  };
-
-  const fixTransitionSymbol = () => {
-    setTransitions(prevTransitions => prevTransitions.map(transition =>
-      transition.update("symbol", symbol => alphabet.includes(symbol) ? symbol : "")
-    ));
-  };
-
-  const fixTransitionNextStates = () => {
-    setTransitions(prevTransitions => prevTransitions.map(transition =>
-      transition.update("nextStates", nextStates => nextStates.intersect(stateIds))
-    ));
-  };
-
-  React.useEffect(fixInitialStateId, [stateIds]);
-  React.useEffect(fixTransitionSymbol, [alphabet]);
-  React.useEffect(fixFinalStateIds, [stateIds]);
-  React.useEffect(fixTransitionCurrentStates, [stateIds]);
-  React.useEffect(fixTransitionNextStates, [stateIds]);
-
-  const stepContent = [
-    <AlphabetInput
-      alphabet={alphabet}
-      onAlphabetChange={setAlphabet}
-      alphabetPresetIndex={alphabetPresetIndex}
-      onAlphabetPresetIndexChange={setAlphabetPresetIndex}
-      errorState={errorState.get("alphabet")}
-      helperText={helperText.get("alphabet")}
-    />,
-    <StatesInput
-      states={states}
-      onStatesChange={setStates}
-      initialStateId={initialStateId}
-      onInitialStateIdChange={setInitialStateId}
-      finalStateIds={finalStateIds}
-      onFinalStateIdsChange={setFinalStateIds}
-      errorState={errorState.get("states")}
-      helperText={helperText.get("states")}
-      errorAlertText={errorAlertText.get("states")}
-      warningAlertText={warningAlertText.get("states")}
-    />,
-    <TransitionsInput
-      transitions={transitions}
-      onTransitionsChange={setTransitions}
-      alphabet={alphabet}
-      states={states}
-      errorState={errorState.get("transitions")}
-      helperText={helperText.get("transitions")}
-      warningAlertText={warningAlertText.get("transitions")}
-    />,
-  ];
-
-  const countErrors = key => errorState.get(key).toList().flatten().count(x => x === true)
-    + (errorAlertText.has(key) ? errorAlertText.get(key).count() : 0);
-
-  // TODO: Maybe remove this and put warningCount and errorCount in their own Maps
-  const steps = List([
-    Map({
-      label: "Specify alphabet",
-      completed: countErrors("alphabet") === 0,
-      errorCount: countErrors("alphabet"),
-    }),
-    Map({
-      label: "Specify states",
-      completed: countErrors("states") === 0,
-      errorCount: countErrors("states"),
-      warningCount: warningAlertText.get("states").count(),
-    }),
-    Map({
-      label: "Specify transitions",
-      completed: countErrors("transitions") === 0,
-      errorCount: countErrors("transitions"),
-      warningCount: warningAlertText.get("transitions").count(),
-    }),
-  ]);
-  const [activeStepIndex, setActiveStepIndex] = React.useState(0);
-
-  const allStepsCompleted = () => steps.every(step => step.get("completed") === true);
-
-  const handleNext = () => {
-    const updatedActiveStepIndex =
-      activeStepIndex === steps.count() - 1 && !allStepsCompleted()
-        ? // It's the last step, but not all steps have been completed
-          // find the first step that has not been completed
-        steps.findIndex(step => step.get("completed") === false)
-        : activeStepIndex + 1;
-
-    setActiveStepIndex(updatedActiveStepIndex);
-  };
-
-  const handleBack = () => setActiveStepIndex(prevActiveStep => prevActiveStep - 1);
-
-  const handleStep = stepIndex => () => setActiveStepIndex(stepIndex);
-
-  const handleFinish = () => {
-    let automaton = createAutomaton(alphabet, states, initialStateId, finalStateIds, transitions);
-    addAutomaton(automaton);
-    history.push("/");
-    openSnackbar();
-  };
-
-  return (
-    <div className={classes.root}>
-      <Stepper alternativeLabel nonLinear activeStep={activeStepIndex} style={{backgroundColor: "transparent"}}>
-        {steps.map((step, index) => (
-          <Step key={index}>
-            <StepButton
-              onClick={handleStep(index)}
-              completed={step.get("completed")}
-              optional={(step.get("errorCount") > 0 && (
-                <Typography variant="caption" color="error">
-                  {step.get("errorCount")} {step.get("errorCount") === 1 ? "error" : "errors"}
-                </Typography>
-              )) || (step.has("warningCount") && step.get("warningCount") > 0 && (
-                <Typography variant="caption">
-                  {step.get("warningCount")} {step.get("warningCount") === 1 ? "warning" : "warnings"}
-                </Typography>
-              ))}
-            >
-              <StepLabel error={step.get("errorCount") > 0}>{step.get("label")}</StepLabel>
-            </StepButton>
-          </Step>
-        ))}
-      </Stepper>
-      {stepContent[activeStepIndex]}
-      <Button disabled={activeStepIndex === 0} onClick={handleBack} className={classes.button}>
-        Back
-      </Button>
-      <Button
-        variant="contained"
-        color="primary"
-        onClick={handleNext}
-        className={classes.button}
-        disabled={activeStepIndex === steps.count() - 1 && allStepsCompleted()}
-      >
-        Next
-      </Button>
-      <Button variant="contained" color="primary" onClick={handleFinish} disabled={!allStepsCompleted()}>
-        Finish
-      </Button>
-    </div>
-  );
-}
Index: src/Header.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Header.js b/src/Header.tsx
rename from src/Header.js
rename to src/Header.tsx
--- a/src/Header.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/Header.tsx	(date 1612022976070)
@@ -5,11 +5,11 @@
 import Button from "@material-ui/core/Button";
 import AppBar from "@material-ui/core/AppBar";
 import React from "react";
-import {makeStyles} from "@material-ui/core/styles";
+import {makeStyles, Theme} from "@material-ui/core/styles";
 import Tooltip from "@material-ui/core/Tooltip";
 import GitHubIcon from "@material-ui/icons/GitHub";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   root: {
     flexGrow: 1,
   },
Index: src/Home.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Home.js b/src/Home.tsx
rename from src/Home.js
rename to src/Home.tsx
--- a/src/Home.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/Home.tsx	(date 1612022976082)
@@ -1,8 +1,8 @@
-import React from "react";
+import React, {Dispatch, SetStateAction} from "react";
 import Typography from "@material-ui/core/Typography";
 import Fab from "@material-ui/core/Fab";
 import AddIcon from '@material-ui/icons/Add';
-import {makeStyles} from "@material-ui/core/styles";
+import {makeStyles, Theme} from "@material-ui/core/styles";
 import {Link} from "react-router-dom";
 import List from "@material-ui/core/List";
 import ListItem from "@material-ui/core/ListItem";
@@ -16,8 +16,10 @@
 import DialogContentText from "@material-ui/core/DialogContentText";
 import DialogTitle from "@material-ui/core/DialogTitle";
 import Button from "@material-ui/core/Button";
+import {Automaton} from "./automaton";
+import Immutable from "immutable";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   fab: {
     position: 'absolute',
     bottom: theme.spacing(4),
@@ -25,23 +27,29 @@
   },
 }));
 
-export default function Home({automata, onAutomataChange, openSnackbar}) {
+type HomeProps = {
+  automata: Immutable.List<Automaton>;
+  onAutomataChange: Dispatch<SetStateAction<Immutable.List<Automaton>>>;
+  openSnackbar: () => void;
+};
+
+export default function Home({automata, onAutomataChange, openSnackbar}: HomeProps) {
   const classes = useStyles();
 
   const [dialogOpen, setDialogOpen] = React.useState(false);
-  const [automatonDeleteIndex, setAutomatonDeleteIndex] = React.useState(null);
+  const [automatonDeleteIndex, setAutomatonDeleteIndex] = React.useState<number | null>(null);
 
-  const handleRemoveAutomatonClick = index => {
+  const handleRemoveAutomatonClick = (index: number): void => {
     setAutomatonDeleteIndex(index);
     setDialogOpen(true);
   }
 
-  const handleDialogClose = () => {
+  const handleDialogClose = (): void => {
     setDialogOpen(false);
   };
 
-  const handleDialogConfirmClick = () => {
-    onAutomataChange(prevAutomata => prevAutomata.delete(automatonDeleteIndex));
+  const handleDialogConfirmClick = (): void => {
+    onAutomataChange((prevAutomata: Immutable.List<Automaton>): Immutable.List<Automaton> => prevAutomata.delete(automatonDeleteIndex as number));
     openSnackbar();
     setDialogOpen(false);
   };
@@ -59,7 +67,7 @@
         </>
       ) : (
         <List>
-          {automata.map((automaton, index) => (
+          {automata.map((automaton: Automaton, index: number) => (
             <React.Fragment key={index}>
               <ListItem key={index}>
                 <ListItemText
@@ -92,7 +100,7 @@
         <DialogTitle id="alert-dialog-title">{"Delete automaton?"}</DialogTitle>
         <DialogContent>
           <DialogContentText id="alert-dialog-description">
-            Are you sure you wish to permanently delete Automaton {automatonDeleteIndex + 1}? This cannot be undone.
+            Are you sure you wish to permanently delete Automaton {automatonDeleteIndex! + 1}? This cannot be undone.
           </DialogContentText>
         </DialogContent>
         <DialogActions>
Index: src/TransitionsInput.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/TransitionsInput.js b/src/TransitionsInput.tsx
rename from src/TransitionsInput.js
rename to src/TransitionsInput.tsx
--- a/src/TransitionsInput.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/TransitionsInput.tsx	(date 1612047256534)
@@ -1,6 +1,6 @@
-import React from "react";
-import {Record, Set} from "immutable";
-import {makeStyles} from "@material-ui/core/styles";
+import React, {Dispatch, SetStateAction} from "react";
+import {List, Map, Record, Set} from "immutable";
+import {makeStyles, Theme} from "@material-ui/core/styles";
 import FormControl from "@material-ui/core/FormControl";
 import InputLabel from "@material-ui/core/InputLabel";
 import Select from "@material-ui/core/Select";
@@ -15,8 +15,13 @@
 import Alert from "@material-ui/lab/Alert";
 import AlertTitle from "@material-ui/lab/AlertTitle";
 import clsx from "clsx";
+import {Transition, TransitionRecord} from "./transition";
+import {State} from "./state";
+import {Alphabet} from "./alphabet";
+import {findStateById} from "./utilities";
+import {TransitionsErrorState, TransitionsHelperText} from "./validation";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   root: {
     '& > *': {
       margin: theme.spacing(1),
@@ -42,59 +47,61 @@
   },
 }));
 
+type TransitionsInputProps = {
+  transitions: List<Transition>;
+  alphabet: Alphabet;
+  states: List<State>;
+  errorState: TransitionsErrorState;
+  helperText: TransitionsHelperText;
+  warningAlertText: string[];
+};
+
 export default function TransitionsInput({
                                            transitions,
-                                           onTransitionsChange,
                                            alphabet,
                                            states,
                                            errorState,
                                            helperText,
                                            warningAlertText,
-                                         }) {
+                                         }: TransitionsInputProps) {
   const classes = useStyles();
 
-  const Transition = Record({
-    currentState: "",
-    symbol: "",
-    nextStates: Set(),
-  });
-
-  const handleAddTransitionClick = () => {
-    onTransitionsChange(prevTransitions => prevTransitions.push(Transition()));
+  const handleAddTransitionClick = (): void => {
+    onTransitionsChange(prevTransitions => prevTransitions.push(TransitionRecord()));
   };
 
-  const handleRemoveTransitionClick = index => {
+  const handleRemoveTransitionClick = (index: number): void => {
     onTransitionsChange(prevTransitions => prevTransitions.delete(index));
   };
 
-  const handleCurrentStateChange = (event, index) => {
-    const updatedCurrentState = event.target.value;
+  const handleCurrentStateChange = (event: React.ChangeEvent<{ value: unknown }>, index: number) => {
+    const updatedCurrentState = event.target.value as string;
     onTransitionsChange(prevTransitions => prevTransitions.setIn([index, "currentState"], updatedCurrentState));
   };
 
-  const handleSymbolChange = (event, index) => {
-    const updatedSymbol = event.target.value;
+  const handleSymbolChange = (event: React.ChangeEvent<{ value: unknown }>, index: number): void => {
+    const updatedSymbol = event.target.value as string;
     onTransitionsChange(prevTransitions => prevTransitions.setIn([index, "symbol"], updatedSymbol));
   };
 
-  const handleNextStatesChange = (event, index) => {
-    const updatedNextStates = event.target.value;
+  const handleNextStatesChange = (event: React.ChangeEvent<{ value: unknown }>, index: number): void => {
+    const updatedNextStates = event.target.value as string;
     onTransitionsChange(prevTransitions => prevTransitions.setIn([index, "nextStates"], Set(updatedNextStates)));
   };
 
-  const generatePlaceholderStateName = index => `[State ${index + 1}]`;
+  const generatePlaceholderStateName = (index: number): string => states.has(index) ? `[State ${index + 1}]` : "[Invalid]";
 
-  const createStateDisplayName = (state, index) =>
-    state.get("name") === "" ? generatePlaceholderStateName(index) : state.get("name");
+  const createStateDisplayName = (state: State | undefined, index: number): string =>
+    state === undefined || state.get("name") === "" ? generatePlaceholderStateName(index) : state.get("name");
 
   return (
     <>
       <form className={classes.root} autoComplete="off">
-        {transitions.map((transition, index) => (
+        {transitions.map((transition: Transition, index: number) => (
           <React.Fragment key={index}>
             <FormControl
               className={classes.formControl}
-              error={errorState.getIn(["currentState", index])}
+              error={errorState.currentState.get(index)}
               disabled={states.isEmpty()}
             >
               <InputLabel id={`transition-current-state-${index + 1}-label`}>Current state</InputLabel>
@@ -102,8 +109,8 @@
                 labelId={`transition-current-state-${index + 1}-label`}
                 id={`transition-current-state-${index + 1}`}
                 value={transition.get("currentState")}
-                onChange={event => handleCurrentStateChange(event, index)}>
-                {states.map((state, index) =>
+                onChange={event => on(event, index)}>
+                {states.map((state: State, index: number) =>
                   <MenuItem
                     key={index}
                     value={state.get("id")}
@@ -113,7 +120,7 @@
                   </MenuItem>
                 )}
               </Select>
-              <FormHelperText>{helperText.getIn(["currentState", index])}</FormHelperText>
+              <FormHelperText>{helperText.currentState.get(index)}</FormHelperText>
             </FormControl>
             <FormControl
               className={classes.formControl}
@@ -126,15 +133,15 @@
                 id={`transition-symbol-${index + 1}`}
                 value={transition.get("symbol")}
                 onChange={event => handleSymbolChange(event, index)}>
-                {alphabet.map((symbol, index) =>
+                {alphabet.map((symbol: string, index: string) =>
                   <MenuItem key={index} value={symbol}>{symbol}</MenuItem>
                 )}
               </Select>
-              <FormHelperText>{helperText.getIn(["symbol", index])}</FormHelperText>
+              <FormHelperText>{helperText.symbol.get(index)}</FormHelperText>
             </FormControl>
             <FormControl
               className={classes.formControl}
-              error={errorState.getIn(["nextStates", index])}
+              error={errorState.nextStates.get(index)}
               disabled={states.isEmpty()}
             >
               <InputLabel id={`transition-next-states-${index + 1}-label`}>Next states</InputLabel>
@@ -145,24 +152,26 @@
                 value={transition.get("nextStates").sort().toArray()}
                 onChange={event => handleNextStatesChange(event, index)}
                 input={<Input id="transition-next-states-select"/>}
-                renderValue={nextStateIds => (
-                  <div className={classes.chips}>
-                    {nextStateIds.map((nextStateId, index) => {
-                      // TODO: Make this nicer - e.g. by using states instead of state IDs as values here
-                      const state = states.find(state => state.get("id") === nextStateId);
-                      const stateIndex = states.findIndex(state => state.get("id") === nextStateId);
-                      return (
-                        <Chip
-                          key={index}
-                          label={createStateDisplayName(state, stateIndex)}
-                          className={clsx(classes.chip, {[classes.placeholderStateName]: state.get("name") === ""})}
-                        />
-                      );
-                    })}
-                  </div>
-                )}
+                renderValue={(value: unknown) => {
+                  const nextStateIds = value as Array<string>;
+                  return (
+                    <div className={classes.chips}>
+                      {nextStateIds.map((nextStateId: string, index: number) => {
+                        const state = findStateById(states, nextStateId);
+                        const stateIndex = states.findIndex(state => state.get("id") === nextStateId);
+                        return (
+                          <Chip
+                            key={index}
+                            label={createStateDisplayName(state, stateIndex)}
+                            className={clsx(classes.chip, {[classes.placeholderStateName]: state?.get("name") === ""})}
+                          />
+                        );
+                      })}
+                    </div>
+                  );
+                }}
               >
-                {states.map((state, index) => (
+                {states.map((state: State, index: number) => (
                   <MenuItem
                     key={index}
                     value={state.get("id")}
@@ -175,7 +184,7 @@
                   </MenuItem>
                 ))}
               </Select>
-              <FormHelperText>{helperText.getIn(["nextStates", index])}</FormHelperText>
+              <FormHelperText>{helperText.nextStates.get(index)}</FormHelperText>
             </FormControl>
             <Tooltip title={`Delete Transition ${index + 1}`}>
               <IconButton onClick={() => handleRemoveTransitionClick(index)} aria-label="delete">
@@ -186,9 +195,9 @@
         ))}
         <Button onClick={handleAddTransitionClick} variant="contained">Add transition</Button>
       </form>
-      {warningAlertText.isEmpty() || (
+      {warningAlertText && (
         <Alert severity="warning">
-          <AlertTitle>{warningAlertText.count() === 1 ? "Warning" : "Warnings"}</AlertTitle>
+          <AlertTitle>{warningAlertText.length === 1 ? "Warning" : "Warnings"}</AlertTitle>
           <ul>
             {warningAlertText.map((message, index) => (
               <li key={index}>{message}</li>
Index: src/AlphabetInput.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/AlphabetInput.js b/src/AlphabetInput.tsx
rename from src/AlphabetInput.js
rename to src/AlphabetInput.tsx
--- a/src/AlphabetInput.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/AlphabetInput.tsx	(date 1612026842563)
@@ -1,13 +1,15 @@
-import React from "react";
-import {List, Map, OrderedSet, Set} from "immutable";
+import React, {Dispatch, SetStateAction} from "react";
 import FormControl from "@material-ui/core/FormControl";
 import InputLabel from "@material-ui/core/InputLabel";
 import Select from "@material-ui/core/Select";
 import MenuItem from "@material-ui/core/MenuItem";
 import TextField from "@material-ui/core/TextField";
-import {makeStyles} from "@material-ui/core/styles";
+import {makeStyles, Theme} from "@material-ui/core/styles";
+import AlphabetPreset from "./alphabetPreset";
+import {Alphabet} from "./alphabet";
+import {AlphabetErrorState, AlphabetHelperText} from "./validation";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   root: {
     '& > *': {
       margin: theme.spacing(1),
@@ -20,42 +22,42 @@
   },
 }));
 
-const alphabetPresets = List([
-  Map({
+const alphabetPresets: AlphabetPreset[] = [
+  {
     name: "Binary digits (0-1)",
     alphabet: alphabetStringToAlphabet("01"),
-  }),
-  Map({
+  },
+  {
     name: "Decimal digits (0-9)",
     alphabet: alphabetStringToAlphabet("0123456789"),
-  }),
-  Map({
+  },
+  {
     name: "Upper-case letters (A-Z)",
     alphabet: alphabetStringToAlphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
-  }),
-  Map({
+  },
+  {
     name: "Lower-case letters (a-z)",
     alphabet: alphabetStringToAlphabet("abcdefghijklmnopqrstuvwxyz"),
-  }),
-  Map({
+  },
+  {
     name: "Upper- & lower-case letters (A-Z, a-z)",
     alphabet: alphabetStringToAlphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),
-  }),
-  Map({
+  },
+  {
     name: "Custom",
     alphabet: alphabetStringToAlphabet(""),
-  }),
-]);
+  },
+];
 
-function alphabetToAlphabetString(a) {
+function alphabetToAlphabetString(a: Alphabet): string {
   return a.join("");
 }
 
-function alphabetStringToAlphabet(as) {
+function alphabetStringToAlphabet(as: string): Alphabet {
   return OrderedSet(as.split(""));
 }
 
-function alphabetToAlphabetPresetIndex(a) {
+function alphabetToAlphabetPresetIndex(a: Alphabet): number {
   // Check if the entered alphabet matches the alphabet of a preset
   // If so, select this preset
   // (Ignoring order, hence converting both to Sets)
@@ -71,9 +73,18 @@
   return updatedAlphabetPresetIndex;
 }
 
-function alphabetPresetIndexToAlphabet(api) {
-  return alphabetPresets.get(api).get("alphabet");
+function alphabetPresetIndexToAlphabet(api: number): Alphabet | undefined {
+  return alphabetPresets.get(api)?.get("alphabet");
 }
+
+type AlphabetInputProps = {
+  alphabet: Alphabet;
+  onAlphabetChange: Dispatch<SetStateAction<Alphabet>>;
+  alphabetPresetIndex: number | "";
+  onAlphabetPresetIndexChange: Dispatch<SetStateAction<number | "">>;
+  errorState: AlphabetErrorState;
+  helperText: AlphabetHelperText;
+};
 
 export default function AlphabetInput({
                                         alphabet,
@@ -82,29 +93,29 @@
                                         onAlphabetPresetIndexChange,
                                         errorState,
                                         helperText
-                                      }) {
+                                      }: AlphabetInputProps) {
   const classes = useStyles();
 
-  const handleAlphabetPresetChange = event => {
-    const updatedAlphabetPresetIndex = event.target.value;
+  const handleAlphabetPresetChange = (event: React.ChangeEvent<{ value: unknown }>) => {
+    const updatedAlphabetPresetIndex = event.target.value as (number | "");
     onAlphabetPresetIndexChange(updatedAlphabetPresetIndex);
   };
 
-  const handleAlphabetChange = event => {
+  const handleAlphabetChange = (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>) => {
     const updatedAlphabetString = event.target.value;
     const updatedAlphabet = alphabetStringToAlphabet(updatedAlphabetString);
     onAlphabetChange(updatedAlphabet);
   };
 
-  const updateAlphabet = () => {
+  const updateAlphabet = (): void => {
     if (alphabetPresetIndex !== "") {
       onAlphabetChange(a => {
-        return alphabetToAlphabetPresetIndex(a) === alphabetPresetIndex ? a : alphabetPresetIndexToAlphabet(alphabetPresetIndex);
+        return alphabetToAlphabetPresetIndex(a) === alphabetPresetIndex ? a : (alphabetPresetIndexToAlphabet(alphabetPresetIndex) ?? OrderedSet());
       });
     }
   };
 
-  const updateAlphabetPresetIndex = () => {
+  const updateAlphabetPresetIndex = (): void => {
     const updatedAlphabetPresetIndex = alphabetToAlphabetPresetIndex(alphabet);
     onAlphabetPresetIndexChange(updatedAlphabetPresetIndex);
   };
@@ -132,8 +143,8 @@
         label="Alphabet"
         value={alphabetToAlphabetString(alphabet)}
         onChange={handleAlphabetChange}
-        error={errorState.get("alphabet")}
-        helperText={helperText.get("alphabet")}
+        error={errorState.alphabet}
+        helperText={helperText.alphabet}
       />
     </form>
   );
Index: tsconfig.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tsconfig.json b/tsconfig.json
new file mode 100644
--- /dev/null	(date 1612022976390)
+++ b/tsconfig.json	(date 1612022976390)
@@ -0,0 +1,26 @@
+{
+  "compilerOptions": {
+    "target": "ES2015",
+    "lib": [
+      "dom",
+      "dom.iterable",
+      "esnext"
+    ],
+    "allowJs": true,
+    "skipLibCheck": true,
+    "esModuleInterop": true,
+    "allowSyntheticDefaultImports": true,
+    "strict": true,
+    "forceConsistentCasingInFileNames": true,
+    "noFallthroughCasesInSwitch": true,
+    "module": "esnext",
+    "moduleResolution": "node",
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "noEmit": true,
+    "jsx": "react"
+  },
+  "include": [
+    "src"
+  ]
+}
Index: src/validation.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/validation.ts b/src/validation.ts
new file mode 100644
--- /dev/null	(date 1612022976222)
+++ b/src/validation.ts	(date 1612022976222)
@@ -0,0 +1,546 @@
+import {Alphabet} from "./alphabet";
+import {State} from "./state";
+import {List, OrderedSet} from "immutable";
+import {Transition} from "./transition";
+import {NIL} from "uuid";
+import {findStateById} from "./utilities";
+import _ from "lodash";
+
+interface Check<T> {
+  isValid: T;
+  message: string;
+}
+
+interface Errors {
+  alphabet: {
+    isNonEmpty: Check<boolean>;
+  };
+  states: {
+    areStateNamesNonEmpty: Check<boolean[]>;
+    areStateNamesUnique: Check<boolean[]>;
+    exactlyOneInitialState: Check<boolean>;
+    isNonEmpty: Check<boolean>;
+  };
+  transitions: {
+    areCurrentStatesNonEmpty: Check<boolean[]>;
+    areCurrentStatesValid: Check<boolean[]>;
+    areSymbolsNonEmpty: Check<boolean[]>;
+    areTransitionsUnique: Check<boolean[]>;
+    areSymbolsValid: Check<boolean[]>;
+    areNextStatesNonEmpty: Check<boolean[]>;
+    areNextStatesValid: Check<boolean[]>;
+  };
+}
+
+// TODO: Not sure whether to merge this with Errors
+interface Warnings {
+  states: {
+    atLeastOneFinalState: Check<boolean>; // Warning
+  };
+  transitions: {
+    isNonEmpty: Check<boolean>; // Warning
+  };
+}
+
+// interface Messages {
+//   alphabet: {
+//     isNonEmpty: string;
+//   };
+//   states: {
+//     areStateNamesNonEmpty: string;
+//     areStateNamesUnique: string;
+//     exactlyOneInitialState: string;
+//     isNonEmpty: string;
+//     atLeastOneFinalState: string;
+//   };
+//   transitions: {
+//     areCurrentStatesNonEmpty: string;
+//     areCurrentStatesValid: string;
+//     areSymbolsNonEmpty: string;
+//     areTransitionsUnique: string;
+//     // statesIsNonEmpty: string;
+//     // alphabetIsNonEmpty: string;
+//     areSymbolsValid: string;
+//     areNextStatesNonEmpty: string;
+//     areNextStatesValid: string;
+//     isNonEmpty: string;
+//   };
+// }
+
+interface Disabled {
+  transitions: {
+    symbol: Check<boolean[]>;
+    nextStates: Check<boolean[]>;
+    currentState: Check<boolean[]>;
+  };
+}
+
+export interface AlphabetErrorState {
+  alphabet: boolean;
+}
+
+export interface StatesErrorState {
+  stateName: boolean[];
+}
+
+export interface TransitionsErrorState {
+  symbol: boolean[];
+  nextStates: boolean[];
+  currentState: boolean[];
+}
+
+interface ErrorState {
+  alphabet: AlphabetErrorState;
+  states: StatesErrorState;
+  transitions: TransitionsErrorState;
+}
+
+export interface AlphabetHelperText {
+  alphabet: string | true;
+}
+
+export interface StatesHelperText {
+  stateName: (string | true)[];
+}
+
+export interface TransitionsHelperText {
+  symbol: (string | true)[];
+  nextStates: (string | true)[];
+  currentState: (string | true)[];
+}
+
+interface HelperText {
+  alphabet: AlphabetHelperText;
+  states: StatesHelperText;
+  transitions: TransitionsHelperText;
+}
+
+// For single boolean values, can compute error state by doing !(x1 && ... && xn) (each xi is a check)
+// For lists, need to repeat this for each item in the lists
+const createErrorStateList = (errors: Check<boolean[]>[], disabled?: Check<boolean[]>): boolean[] => {
+  let l = errors[0].isValid;
+  for (let i = 1; i < errors.length; i++) {
+    l = _.zipWith(l, errors[i].isValid, (x, y) => x && y);
+  }
+  l = l.map(x => !x);
+
+  if (disabled !== undefined) {
+    l = _.zipWith(disabled.isValid, l, (x, y) => x && y);
+  }
+
+  return l;
+}
+
+const createHelperText = (c: Check<boolean>): string | true => c.isValid || c.message;
+const createHelperTextList = (c: Check<boolean[]>): (string | true)[] => c.isValid.map(x => x || c.message);
+
+// Same idea as `createErrorStateList`
+// TODO: Use null instead of true
+const createHelperTextListMultiple = (errors: Check<boolean[]>[]): (string | true)[] => {
+  let l = createHelperTextList(errors[0]);
+  for (let i = 1; i < errors.length; i++) {
+    const helperText = createHelperTextList(errors[i]);
+    l = _.zipWith(l, helperText, (x, y) => x === true ? y : x);
+  }
+  return l;
+};
+
+const createAlertTextList = (checks: Check<boolean>[]): string[] =>
+  checks.map(c => c.isValid ? null : c.message).filter(x => x !== null) as string[];
+
+export const validate = (alphabet: string[], states: string[], transitions: List<Transition>,
+                         initialStateId: string, finalStateIds: OrderedSet<string>) => {
+  const stateIds = states.map(state => state.get("id")).toSet();
+
+  const errors: Errors = {
+    alphabet: {
+      isNonEmpty: {
+        isValid: !alphabet.isEmpty(),
+        message: "Alphabet cannot be empty",
+      },
+    },
+    states: {
+      isNonEmpty: {
+        isValid: !states.isEmpty(),
+        message: "At least one state is required",
+      },
+      areStateNamesNonEmpty: {
+        isValid: states.map(state => !!state.get("name")),
+        message: "State name cannot be left blank",
+      },
+      areStateNamesUnique: {
+        isValid: states.map(state1 =>
+          states.count(state2 => state2.get("name") === state1.get("name")) === 1
+        ),
+        message: "State name must be unique",
+      },
+      exactlyOneInitialState: {
+        isValid: initialStateId !== NIL,
+        message: "A state must be selected as the initial state",
+      },
+    },
+    transitions: {
+      areCurrentStatesNonEmpty: {
+        isValid: transitions.map(transition => transition.get("currentState") !== ""),
+        message: "Current state cannot be left blank",
+      },
+      areCurrentStatesValid: {
+        isValid: transitions.map(transition => stateIds.includes(transition.get("currentState"))),
+        message: "State does not exist",
+      },
+      areSymbolsNonEmpty: {
+        isValid: transitions.map(transition => transition.get("symbol") !== ""),
+        message: "Symbol cannot be left blank",
+      },
+      areSymbolsValid: {
+        isValid: transitions.map(transition => alphabet.includes(transition.get("symbol"))),
+        message: "Symbol does not exist in alphabet",
+      },
+      areNextStatesNonEmpty: {
+        isValid: transitions.map(transition => !transition.get("nextStates").isEmpty()),
+        message: "Next states cannot be empty",
+      },
+      areNextStatesValid: {
+        isValid: transitions.map(transition => transition.get("nextStates").isSubset(stateIds)),
+        message: "One or more states do not exist"
+      },
+      areTransitionsUnique: {
+        isValid: transitions.map(transition1 => transitions.count(transition2 =>
+          transition1.get("currentState") === transition2.get("currentState")
+          && transition1.get("symbol") === transition2.get("symbol")
+        ) === 1),
+        message: "Transition must be unique",
+      },
+    },
+  };
+
+  // Warning checks to be performed
+  // Similar to `errors` but for warnings (issues where the input is still valid)
+  const warnings: Warnings = {
+    states: {
+      atLeastOneFinalState: {
+        isValid: !finalStateIds.isEmpty(),
+        message: "No state is selected as the final state, so all strings will be rejected by the automaton"
+      },
+    },
+    transitions: {
+      isNonEmpty: {
+        isValid: !transitions.isEmpty(),
+        message: !stateIds.includes(initialStateId) ? "There are no transitions" : (
+          finalStateIds.includes(initialStateId)
+            ? `There are no transitions and initial state "${findStateById(states, initialStateId)!.get("name")}" is a final state, so all strings will be accepted by the automaton`
+            : `There are no transitions and initial state "${findStateById(states, initialStateId)!.get("name")}" is not a final state, so all strings will be rejected by the automaton`
+        ),
+      },
+    },
+  };
+
+  const disabled: Disabled = {
+    transitions: {
+      currentState: {
+        isValid: transitions.map(() => errors.states.isNonEmpty.isValid),
+        message: "There are no states",
+      },
+      symbol: {
+        isValid: transitions.map(() => errors.alphabet.isNonEmpty.isValid),
+        message: "Alphabet is empty",
+      },
+      nextStates: {
+        isValid: transitions.map(() => errors.states.isNonEmpty.isValid),
+        message: "There are no states",
+      },
+    }
+  };
+
+  // applyDependencies([
+  //   [warnings.states.atLeastOneFinalState, !errors.states.isNonEmpty.valid],
+  //   [warnings.transitions.isNonEmpty, !errors.states.exactlyOneInitialState.valid || !warnings.states.atLeastOneFinalState.valid]
+  // !errors.states.isNonEmpty || errors.states.exactlyOneInitialState
+  // ]);
+
+  // Error state for each input
+  // Some inputs may be associated with more than one check - e.g. check state name is non-empty AND unique
+  // Hence need to combine error checks into a boolean value for each input
+  // Could just check whether helper text is non-empty but may want to display helper text not for an error
+  const errorState: ErrorState = {
+    alphabet: {
+      alphabet: !errors.alphabet.isNonEmpty,
+    },
+    states: {
+      stateName: createErrorStateList([
+        errors.states.areStateNamesNonEmpty,
+        errors.states.areStateNamesUnique,
+      ])
+    },
+    transitions: {
+      currentState: createErrorStateList([
+        errors.transitions.areCurrentStatesNonEmpty,
+        errors.transitions.areCurrentStatesValid,
+        errors.transitions.areTransitionsUnique,
+      ], disabled.transitions.currentState),
+      symbol: createErrorStateList([
+        errors.transitions.areSymbolsNonEmpty,
+        errors.transitions.areSymbolsValid,
+        errors.transitions.areTransitionsUnique,
+      ], disabled.transitions.symbol),
+      nextStates: createErrorStateList([
+        errors.transitions.areNextStatesNonEmpty,
+        errors.transitions.areNextStatesValid,
+      ], disabled.transitions.nextStates),
+    },
+  };
+
+  // Helper text for each input
+  // Same idea as `errorState`
+  const helperText: HelperText = {
+    alphabet: {
+      alphabet: createHelperText(errors.alphabet.isNonEmpty),
+    },
+    states: {
+      stateName: createHelperTextListMultiple([
+        errors.states.areStateNamesNonEmpty,
+        errors.states.areStateNamesUnique,
+      ]),
+    },
+    transitions: {
+      currentState: createHelperTextListMultiple([
+        disabled.transitions.currentState,
+        errors.transitions.areCurrentStatesNonEmpty,
+        errors.transitions.areCurrentStatesValid,
+        errors.transitions.areTransitionsUnique,
+      ]),
+      symbol: createHelperTextListMultiple([
+        disabled.transitions.symbol,
+        errors.transitions.areSymbolsNonEmpty,
+        errors.transitions.areSymbolsValid,
+        errors.transitions.areTransitionsUnique,
+      ]),
+      nextStates: createHelperTextListMultiple([
+        disabled.transitions.nextStates,
+        errors.transitions.areNextStatesNonEmpty,
+        errors.transitions.areNextStatesValid,
+      ]),
+    },
+  };
+
+  // List of error messages to display in an alert
+  // Some errors can't be associated with an input - e.g. states or transitions list being empty
+  // Hence these are displayed in an alert
+  const errorAlertText = {
+    alphabet: [],
+    states: createAlertTextList([
+      errors.states.isNonEmpty,
+      errors.states.exactlyOneInitialState,
+    ]),
+    transitions: [],
+  };
+
+  // List of warning messages to display in an alert
+  const warningAlertText = {
+    states: createAlertTextList([
+      warnings.states.atLeastOneFinalState
+    ]),
+    transitions: createAlertTextList([
+      warnings.transitions.isNonEmpty
+    ]),
+  };
+
+  return {errorState, helperText, errorAlertText, warningAlertText};
+}
+
+// export const validateAlphabet = (alphabet: Alphabet) => {
+//   // Error checks to be performed
+//   // Values may be a single boolean value or a List of boolean values, depending on the nature of the check
+//   // For example, a check that is performed on the list of states will be a list of boolean values of the same length
+//   // TODO: Currently `true` means valid which is counterintuitive; might change this
+//   const errors = {
+//     isNonEmpty: !alphabet.isEmpty(),
+//   };
+//
+//   const errorMessages = {
+//     isNonEmpty: "Alphabet cannot be empty",
+//   };
+//
+//   const errorState = {
+//     alphabet: !errors.isNonEmpty,
+//   };
+//
+//   const helperText = {
+//     alphabet: errors.isNonEmpty || errorMessages.isNonEmpty,
+//   };
+//
+//   return [errorState, helperText];
+// };
+//
+// export const validateStates = (states: List<State>, initialStateId: string, finalStateIds: OrderedSet<string>) => {
+//   // Error checks to be performed
+//   // Values may be a single boolean value or a List of boolean values, depending on the nature of the check
+//   // For example, a check that is performed on the list of states will be a list of boolean values of the same length
+//   // TODO: Currently `true` means valid which is counterintuitive; might change this
+//   const errors = {
+//     isNonEmpty: !states.isEmpty(),
+//     areStateNamesNonEmpty: states.map(state => !!state.get("name")),
+//     areStateNamesUnique: states.map(state1 =>
+//       states.count(state2 => state2.get("name") === state1.get("name")) === 1
+//     ),
+//     exactlyOneInitialState: initialStateId !== NIL,
+//   };
+//
+//   const warnings = {
+//     atLeastOneFinalState: !finalStateIds.isEmpty(),
+//   };
+//
+//   const errorMessages = {
+//     isNonEmpty: "At least one state is required",
+//     areStateNamesNonEmpty: "State name cannot be left blank",
+//     areStateNamesUnique: "State name must be unique",
+//     exactlyOneInitialState: "A state must be selected as the initial state"
+//   };
+//
+//   const warningMessages = {
+//     atLeastOneFinalState: "No state is selected as the final state, so all strings will be rejected by the automaton",
+//   };
+//
+//   const errorState = {
+//     stateName: createErrorStateList([
+//       errors.areStateNamesNonEmpty,
+//       errors.areStateNamesUnique,
+//     ])
+//   };
+//
+//   const helperText = {
+//     stateName: createHelperTextList([
+//       errors.areStateNamesNonEmpty,
+//       errors.areStateNamesUnique,
+//     ], [
+//       errorMessages.areStateNamesNonEmpty,
+//       errorMessages.areStateNamesUnique,
+//     ]),
+//   };
+//
+//   const errorAlertText = createAlertTextList([
+//     errors.isNonEmpty,
+//     !errors.isNonEmpty || errors.exactlyOneInitialState,
+//   ], [
+//     errorMessages.isNonEmpty,
+//     errorMessages.exactlyOneInitialState,
+//   ]);
+//
+//   const warningAlertText = createAlertTextList([
+//     !errors.isNonEmpty || warnings.atLeastOneFinalState
+//   ], [
+//     warningMessages.atLeastOneFinalState,
+//   ]);
+//
+//   return [errorState, helperText, errorAlertText, warningAlertText];
+// };
+//
+// export const validateTransitions = (alphabet: Alphabet, states: List<State>, transitions: List<Transition>, initialStateId, finalStateIds) => {
+//   const stateIds = states.map(state => state.get("id")).toSet();
+//
+//   // Error checks to be performed
+//   // Values may be a single boolean value or a List of boolean values, depending on the nature of the check
+//   // For example, a check that is performed on the list of states will be a list of boolean values of the same length
+//   // TODO: Currently `true` means valid which is counterintuitive; might change this
+//   const errors = {
+//     areCurrentStatesNonEmpty: transitions.map(transition => transition.get("currentState") !== ""),
+//     areCurrentStatesValid: transitions.map(transition => stateIds.includes(transition.get("currentState"))),
+//     areSymbolsNonEmpty: transitions.map(transition => transition.get("symbol") !== ""),
+//     areSymbolsValid: transitions.map(transition => alphabet.includes(transition.get("symbol"))),
+//     areNextStatesNonEmpty: transitions.map(transition => !transition.get("nextStates").isEmpty()),
+//     areNextStatesValid: transitions.map(transition => transition.get("nextStates").isSubset(stateIds)),
+//     areTransitionsUnique: transitions.map(transition1 => transitions.count(transition2 =>
+//       transition1.get("currentState") === transition2.get("currentState")
+//       && transition1.get("symbol") === transition2.get("symbol")
+//     ) === 1),
+//   };
+//
+//   const warnings = {
+//     isNonEmpty: !transitions.isEmpty(),
+//   };
+//
+//   const disabled = {
+//     currentState: transitions.map(() => !states.isEmpty()),
+//     symbol: transitions.map(() => !alphabet.isEmpty()),
+//     nextStates: transitions.map(() => !states.isEmpty()),
+//   };
+//
+//   const errorMessages = {
+//     areCurrentStatesNonEmpty: "Current state cannot be left blank",
+//     areCurrentStatesValid: "State does not exist",
+//     areSymbolsNonEmpty: "Symbol cannot be left blank",
+//     areSymbolsValid: "Symbol does not exist in alphabet",
+//     areNextStatesNonEmpty: "Next states cannot be empty",
+//     areNextStatesValid: "One or more states do not exist",
+//     areTransitionsUnique: "Transition must be unique",
+//     statesIsNonEmpty: "There are no states",
+//     alphabetIsNonEmpty: "Alphabet is empty",
+//   };
+//
+//   const warningMessages = {
+//     isNonEmpty: !stateIds.includes(initialStateId) ? "There are no transitions" : (
+//       finalStateIds.includes(initialStateId)
+//         ? `There are no transitions and initial state "${findStateById(states, initialStateId)!.get("name")}" is a final state, so all strings will be accepted by the automaton`
+//         : `There are no transitions and initial state "${findStateById(states, initialStateId)!.get("name")}" is not a final state, so all strings will be rejected by the automaton`
+//     ),
+//   };
+//
+//   const errorState = {
+//     currentState: createErrorStateList([
+//       errors.areCurrentStatesNonEmpty,
+//       errors.areCurrentStatesValid,
+//       errors.areTransitionsUnique,
+//     ], disabled.currentState),
+//     symbol: createErrorStateList([
+//       errors.areSymbolsNonEmpty,
+//       errors.areSymbolsValid,
+//       errors.areTransitionsUnique,
+//     ], disabled.symbol),
+//     nextStates: createErrorStateList([
+//       errors.areNextStatesNonEmpty,
+//       errors.areNextStatesValid,
+//     ], disabled.nextStates),
+//   };
+//
+//   const helperText = {
+//     currentState: createHelperTextList([
+//       disabled.currentState,
+//       errors.areCurrentStatesNonEmpty,
+//       errors.areCurrentStatesValid,
+//       errors.areTransitionsUnique,
+//     ], [
+//       errorMessages.statesIsNonEmpty,
+//       errorMessages.areCurrentStatesNonEmpty,
+//       errorMessages.areCurrentStatesValid,
+//       errorMessages.areTransitionsUnique,
+//     ]),
+//     symbol: createHelperTextList([
+//       disabled.symbol,
+//       errors.areSymbolsNonEmpty,
+//       errors.areSymbolsValid,
+//       errors.areTransitionsUnique,
+//     ], [
+//       errorMessages.alphabetIsNonEmpty,
+//       errorMessages.areSymbolsNonEmpty,
+//       errorMessages.areSymbolsValid,
+//       errorMessages.areTransitionsUnique,
+//     ]),
+//     nextStates: createHelperTextList([
+//       disabled.nextStates,
+//       errors.areNextStatesNonEmpty,
+//       errors.areNextStatesValid,
+//     ], [
+//       errorMessages.statesIsNonEmpty,
+//       errorMessages.areNextStatesNonEmpty,
+//       errorMessages.areNextStatesValid,
+//     ]),
+//   };
+//
+//   const warningAlertText = createAlertTextList([
+//     !errors.states.exactlyOneInitialState || !warnings.states.atLeastOneFinalState || warnings.isNonEmpty
+//   ], [
+//     warningMessages.isNonEmpty,
+//   ]);
+//
+//   return [errorState, helperText, errorAlertText, warningAlertText];
+// };
Index: src/utilities.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/utilities.ts b/src/utilities.ts
new file mode 100644
--- /dev/null	(date 1612022976214)
+++ b/src/utilities.ts	(date 1612022976214)
@@ -0,0 +1,6 @@
+import {State} from "./state";
+import {List} from "immutable";
+
+export function findStateById(states: List<State>, id: string): State | undefined {
+  return states.find(state => state.get("id") === id);
+}
Index: src/transition.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/transition.ts b/src/transition.ts
new file mode 100644
--- /dev/null	(date 1612046110079)
+++ b/src/transition.ts	(date 1612046110079)
@@ -0,0 +1,5 @@
+export default interface Transition {
+  currentState: string;
+  symbol: string;
+  nextStates: Set<string>;
+}
Index: src/state.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/state.ts b/src/state.ts
new file mode 100644
--- /dev/null	(date 1612030284282)
+++ b/src/state.ts	(date 1612030284282)
@@ -0,0 +1,4 @@
+export default interface State {
+  id: string;
+  name: string;
+}
Index: src/snackbarMessage.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/snackbarMessage.ts b/src/snackbarMessage.ts
new file mode 100644
--- /dev/null	(date 1612022976130)
+++ b/src/snackbarMessage.ts	(date 1612022976130)
@@ -0,0 +1,14 @@
+import {Record, RecordOf} from "immutable";
+import {v4 as uuidv4} from "uuid";
+
+interface SnackbarMessageProps {
+  id: string | null;
+  message: string;
+}
+
+export const SnackbarMessageRecord = Record<SnackbarMessageProps>({
+  id: uuidv4(),
+  message: "",
+});
+
+export type SnackbarMessage = RecordOf<SnackbarMessageProps>;
Index: src/react-app-env.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/react-app-env.d.ts b/src/react-app-env.d.ts
new file mode 100644
--- /dev/null	(date 1612022976126)
+++ b/src/react-app-env.d.ts	(date 1612022976126)
@@ -0,0 +1,1 @@
+/// <reference types="react-scripts" />
Index: src/automaton.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/automaton.ts b/src/automaton.ts
new file mode 100644
--- /dev/null	(date 1612022976058)
+++ b/src/automaton.ts	(date 1612022976058)
@@ -0,0 +1,48 @@
+import {List, Map, OrderedSet, Record, RecordOf, Set} from "immutable";
+import {State, StateRecord} from "./state";
+import {Transition} from "./transition";
+import {findStateById} from "./utilities";
+import {Alphabet} from "./alphabet";
+
+interface TransitionFunctionKey {
+  currentState: string;
+  symbol: string;
+}
+
+export default class Automaton {
+  alphabet: Alphabet;
+  states: OrderedSet<State>;
+  transitionFunction: Map<TransitionFunctionKey, Set<string>>;
+  initialState: State | undefined;
+  finalStates: Set<State>;
+
+  constructor(alphabet: Alphabet, states: OrderedSet<State>,
+              transitionFunction: Map<TransitionFunctionKey, Set<string>>, initialState: State | undefined,
+              finalStates: Set<State>) {
+    this.alphabet = alphabet;
+    this.states = states;
+    this.transitionFunction = transitionFunction;
+    this.initialState = initialState;
+    this.finalStates = finalStates;
+  }
+
+  // TODO: States in the automaton do not need to contain IDs
+  static createAutomaton(alphabet: Alphabet, states: List<State>, transitions: List<Transition>, initialStateId: string,
+                         finalStateIds: Set<string>): Automaton {
+    const transitionsToTransitionFunction = (transitions: List<Transition>): Map<TransitionFunctionKey, Set<string>> => {
+      let transitionFunction: Map<TransitionFunctionKey, Set<string>> = Map();
+      for (const transition of transitions) {
+        const key = {
+          currentState: transition.get("currentState"),
+          symbol: transition.get("symbol"),
+        };
+        transitionFunction = transitionFunction.set(key, transition.get("nextStates"));
+      }
+      return transitionFunction;
+    }
+
+    return new Automaton(alphabet, OrderedSet(states), transitionsToTransitionFunction(transitions),
+      findStateById(states, initialStateId),
+      states.filter(state => finalStateIds.includes(state.get("id"))).toSet());
+  }
+}
Index: package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/package.json b/package.json
--- a/package.json	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/package.json	(date 1612030603629)
@@ -9,12 +9,24 @@
     "@testing-library/jest-dom": "^5.11.6",
     "@testing-library/react": "^11.2.1",
     "@testing-library/user-event": "^12.2.2",
+    "@types/jest": "^26.0.20",
+    "@types/lodash": "^4.14.168",
+    "@types/node": "^14.14.21",
+    "@types/ramda": "^0.27.36",
+    "@types/react": "^17.0.0",
+    "@types/react-dom": "^17.0.0",
+    "@types/react-router-dom": "^5.1.7",
+    "@types/uuid": "^8.3.0",
     "clsx": "^1.1.1",
-    "immutable": "^4.0.0-rc.12",
+    "immer": "^8.0.1",
+    "lodash": "^4.17.20",
+    "ramda": "^0.27.1",
     "react": "^17.0.1",
     "react-dom": "^17.0.1",
     "react-router-dom": "^5.2.0",
     "react-scripts": "4.0.0",
+    "typescript": "~4.0.5",
+    "use-immer": "^0.4.2",
     "uuid": "^8.3.2",
     "web-vitals": "^0.2.4"
   },
Index: src/alphabetPreset.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/alphabetPreset.ts b/src/alphabetPreset.ts
new file mode 100644
--- /dev/null	(date 1612026128036)
+++ b/src/alphabetPreset.ts	(date 1612026128036)
@@ -0,0 +1,6 @@
+import {Alphabet} from "./alphabet";
+
+export default interface AlphabetPreset {
+  name: string;
+  alphabet: Alphabet;
+}
Index: package-lock.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/package-lock.json b/package-lock.json
--- a/package-lock.json	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/package-lock.json	(date 1612030603957)
@@ -2354,6 +2354,11 @@
         "@types/node": "*"
       }
     },
+    "@types/history": {
+      "version": "4.7.8",
+      "resolved": "https://registry.npmjs.org/@types/history/-/history-4.7.8.tgz",
+      "integrity": "sha512-S78QIYirQcUoo6UJZx9CSP0O2ix9IaeAXwQi26Rhr/+mg7qqPy8TzaxHSUut7eGjL8WmLccT7/MXf304WjqHcA=="
+    },
     "@types/html-minifier-terser": {
       "version": "5.1.1",
       "resolved": "https://registry.npmjs.org/@types/html-minifier-terser/-/html-minifier-terser-5.1.1.tgz",
@@ -2381,9 +2386,9 @@
       }
     },
     "@types/jest": {
-      "version": "26.0.15",
-      "resolved": "https://registry.npmjs.org/@types/jest/-/jest-26.0.15.tgz",
-      "integrity": "sha512-s2VMReFXRg9XXxV+CW9e5Nz8fH2K1aEhwgjUqPPbQd7g95T0laAcvLv032EhFHIa5GHsZ8W7iJEQVaJq6k3Gog==",
+      "version": "26.0.20",
+      "resolved": "https://registry.npmjs.org/@types/jest/-/jest-26.0.20.tgz",
+      "integrity": "sha512-9zi2Y+5USJRxd0FsahERhBwlcvFh6D2GLQnY2FH2BzK8J9s9omvNHIbvABwIluXa0fD8XVKMLTO0aOEuUfACAA==",
       "requires": {
         "jest-diff": "^26.0.0",
         "pretty-format": "^26.0.0"
@@ -2399,15 +2404,20 @@
       "resolved": "https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz",
       "integrity": "sha1-7ihweulOEdK4J7y+UnC86n8+ce4="
     },
+    "@types/lodash": {
+      "version": "4.14.168",
+      "resolved": "https://registry.npmjs.org/@types/lodash/-/lodash-4.14.168.tgz",
+      "integrity": "sha512-oVfRvqHV/V6D1yifJbVRU3TMp8OT6o6BG+U9MkwuJ3U8/CsDHvalRpsxBqivn71ztOFZBTfJMvETbqHiaNSj7Q=="
+    },
     "@types/minimatch": {
       "version": "3.0.3",
       "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz",
       "integrity": "sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA=="
     },
     "@types/node": {
-      "version": "14.14.8",
-      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.14.8.tgz",
-      "integrity": "sha512-z/5Yd59dCKI5kbxauAJgw6dLPzW+TNOItNE00PkpzNwUIEwdj/Lsqwq94H5DdYBX7C13aRA0CY32BK76+neEUA=="
+      "version": "14.14.21",
+      "resolved": "https://registry.npmjs.org/@types/node/-/node-14.14.21.tgz",
+      "integrity": "sha512-cHYfKsnwllYhjOzuC5q1VpguABBeecUp24yFluHpn/BQaVxB1CuQ1FSRZCzrPxrkIfWISXV2LbeoBthLWg0+0A=="
     },
     "@types/normalize-package-data": {
       "version": "2.4.0",
@@ -2434,21 +2444,56 @@
       "resolved": "https://registry.npmjs.org/@types/q/-/q-1.5.4.tgz",
       "integrity": "sha512-1HcDas8SEj4z1Wc696tH56G8OlRaH/sqZOynNNB+HF0WOeXPaxTtbYzJY2oEfiUxjSKjhCKr+MvR7dCHcEelug=="
     },
+    "@types/ramda": {
+      "version": "0.27.36",
+      "resolved": "https://registry.npmjs.org/@types/ramda/-/ramda-0.27.36.tgz",
+      "integrity": "sha512-E0eLH6AdViBD1qkoTZlUpRSY0+xvJMVBqfGp7eOwXqftZ7X8gmTKnxzVDPsAuJPEeU600vD2Df3gfTZTeZ6fTA==",
+      "requires": {
+        "ts-toolbelt": "^6.15.1"
+      }
+    },
     "@types/react": {
-      "version": "16.9.56",
-      "resolved": "https://registry.npmjs.org/@types/react/-/react-16.9.56.tgz",
-      "integrity": "sha512-gIkl4J44G/qxbuC6r2Xh+D3CGZpJ+NdWTItAPmZbR5mUS+JQ8Zvzpl0ea5qT/ZT3ZNTUcDKUVqV3xBE8wv/DyQ==",
+      "version": "17.0.0",
+      "resolved": "https://registry.npmjs.org/@types/react/-/react-17.0.0.tgz",
+      "integrity": "sha512-aj/L7RIMsRlWML3YB6KZiXB3fV2t41+5RBGYF8z+tAKU43Px8C3cYUZsDvf1/+Bm4FK21QWBrDutu8ZJ/70qOw==",
       "requires": {
         "@types/prop-types": "*",
         "csstype": "^3.0.2"
       },
       "dependencies": {
         "csstype": {
-          "version": "3.0.5",
-          "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.0.5.tgz",
-          "integrity": "sha512-uVDi8LpBUKQj6sdxNaTetL6FpeCqTjOvAQuQUa/qAqq8oOd4ivkbhgnqayl0dnPal8Tb/yB1tF+gOvCBiicaiQ=="
+          "version": "3.0.6",
+          "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.0.6.tgz",
+          "integrity": "sha512-+ZAmfyWMT7TiIlzdqJgjMb7S4f1beorDbWbsocyK4RaiqA5RTX3K14bnBWmmA9QEM0gRdsjyyrEmcyga8Zsxmw=="
         }
       }
+    },
+    "@types/react-dom": {
+      "version": "17.0.0",
+      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-17.0.0.tgz",
+      "integrity": "sha512-lUqY7OlkF/RbNtD5nIq7ot8NquXrdFrjSOR6+w9a9RFQevGi1oZO1dcJbXMeONAPKtZ2UrZOEJ5UOCVsxbLk/g==",
+      "requires": {
+        "@types/react": "*"
+      }
+    },
+    "@types/react-router": {
+      "version": "5.1.11",
+      "resolved": "https://registry.npmjs.org/@types/react-router/-/react-router-5.1.11.tgz",
+      "integrity": "sha512-ofHbZMlp0Y2baOHgsWBQ4K3AttxY61bDMkwTiBOkPg7U6C/3UwwB5WaIx28JmSVi/eX3uFEMRo61BV22fDQIvg==",
+      "requires": {
+        "@types/history": "*",
+        "@types/react": "*"
+      }
+    },
+    "@types/react-router-dom": {
+      "version": "5.1.7",
+      "resolved": "https://registry.npmjs.org/@types/react-router-dom/-/react-router-dom-5.1.7.tgz",
+      "integrity": "sha512-D5mHD6TbdV/DNHYsnwBTv+y73ei+mMjrkGrla86HthE4/PVvL1J94Bu3qABU+COXzpL23T1EZapVVpwHuBXiUg==",
+      "requires": {
+        "@types/history": "*",
+        "@types/react": "*",
+        "@types/react-router": "*"
+      }
     },
     "@types/react-transition-group": {
       "version": "4.4.0",
@@ -2504,6 +2549,11 @@
         }
       }
     },
+    "@types/uuid": {
+      "version": "8.3.0",
+      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-8.3.0.tgz",
+      "integrity": "sha512-eQ9qFW/fhfGJF8WKHGEHZEyVWfZxrT+6CLIJGBcZPfxUh/+BnEj+UCGYMlr9qZuX/2AltsvwrGqp0LhEW8D0zQ=="
+    },
     "@types/webpack": {
       "version": "4.41.25",
       "resolved": "https://registry.npmjs.org/@types/webpack/-/webpack-4.41.25.tgz",
@@ -7577,14 +7627,9 @@
       "integrity": "sha512-BMpfD7PpiETpBl/A6S498BaIJ6Y/ABT93ETbby2fP00v4EbvPBXWEoaR1UBPKs3iR53pJY7EtZk5KACI57i1Uw=="
     },
     "immer": {
-      "version": "7.0.9",
-      "resolved": "https://registry.npmjs.org/immer/-/immer-7.0.9.tgz",
-      "integrity": "sha512-Vs/gxoM4DqNAYR7pugIxi0Xc8XAun/uy7AQu4fLLqaTBHxjOP9pJ266Q9MWA/ly4z6rAFZbvViOtihxUZ7O28A=="
-    },
-    "immutable": {
-      "version": "4.0.0-rc.12",
-      "resolved": "https://registry.npmjs.org/immutable/-/immutable-4.0.0-rc.12.tgz",
-      "integrity": "sha512-0M2XxkZLx/mi3t8NVwIm1g8nHoEmM9p9UBl/G9k4+hm0kBgOVdMV/B3CY5dQ8qG8qc80NN4gDV4HQv6FTJ5q7A=="
+      "version": "8.0.1",
+      "resolved": "https://registry.npmjs.org/immer/-/immer-8.0.1.tgz",
+      "integrity": "sha512-aqXhGP7//Gui2+UrEtvxZxSquQVXTpZ7KDxfCcKAF3Vysvw0CViVaW9RZ1j1xlIYqaaaipBoqdqeibkc18PNvA=="
     },
     "import-cwd": {
       "version": "2.1.0",
@@ -12512,6 +12557,11 @@
         "performance-now": "^2.1.0"
       }
     },
+    "ramda": {
+      "version": "0.27.1",
+      "resolved": "https://registry.npmjs.org/ramda/-/ramda-0.27.1.tgz",
+      "integrity": "sha512-PgIdVpn5y5Yns8vqb8FzBUEYn98V3xcPgawAkkgj0YJ0qDsnHCiNmZYfOGMgOvoB0eWFLpYbhxUR3mxfDIMvpw=="
+    },
     "randombytes": {
       "version": "2.1.0",
       "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
@@ -12631,6 +12681,11 @@
           "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-2.0.0.tgz",
           "integrity": "sha512-UpzcLCXolUWcNu5HtVMHYdXJjArjsF9C0aNnquZYY4uW/Vu0miy5YoWvbV345HauVvcAUnpRuhMMcqTcGOY2+w=="
         },
+        "immer": {
+          "version": "7.0.9",
+          "resolved": "https://registry.npmjs.org/immer/-/immer-7.0.9.tgz",
+          "integrity": "sha512-Vs/gxoM4DqNAYR7pugIxi0Xc8XAun/uy7AQu4fLLqaTBHxjOP9pJ266Q9MWA/ly4z6rAFZbvViOtihxUZ7O28A=="
+        },
         "path-key": {
           "version": "3.1.1",
           "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
@@ -15045,6 +15100,11 @@
       "resolved": "https://registry.npmjs.org/ts-pnp/-/ts-pnp-1.2.0.tgz",
       "integrity": "sha512-csd+vJOb/gkzvcCHgTGSChYpy5f1/XKNsmvBGO4JXS+z1v2HobugDz4s1IeFXM3wZB44uczs+eazB5Q/ccdhQw=="
     },
+    "ts-toolbelt": {
+      "version": "6.15.5",
+      "resolved": "https://registry.npmjs.org/ts-toolbelt/-/ts-toolbelt-6.15.5.tgz",
+      "integrity": "sha512-FZIXf1ksVyLcfr7M317jbB67XFJhOO1YqdTcuGaq9q5jLUoTikukZ+98TPjKiP2jC5CgmYdWWYs0s2nLSU0/1A=="
+    },
     "tsconfig-paths": {
       "version": "3.9.0",
       "resolved": "https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.9.0.tgz",
@@ -15142,6 +15202,11 @@
         "is-typedarray": "^1.0.0"
       }
     },
+    "typescript": {
+      "version": "4.0.5",
+      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.0.5.tgz",
+      "integrity": "sha512-ywmr/VrTVCmNTJ6iV2LwIrfG1P+lv6luD8sUJs+2eI9NLGigaN+nUQc13iHqisq7bra9lnmUSYqbJvegraBOPQ=="
+    },
     "unicode-canonical-property-names-ecmascript": {
       "version": "1.0.4",
       "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-1.0.4.tgz",
@@ -15332,6 +15397,11 @@
       "resolved": "https://registry.npmjs.org/use/-/use-3.1.1.tgz",
       "integrity": "sha512-cwESVXlO3url9YWlFW/TA9cshCEhtu7IKJ/p5soJ/gGpj7vbvFrAY/eIioQ6Dw23KjZhYgiIo8HOs1nQ2vr/oQ=="
     },
+    "use-immer": {
+      "version": "0.4.2",
+      "resolved": "https://registry.npmjs.org/use-immer/-/use-immer-0.4.2.tgz",
+      "integrity": "sha512-ONfZHEv/gzt/jyYxrJD3ZFUllKJED8F1mds9Fr9CYj54LmsiuGDg3vkx+R7WHS72p7DbSS1QbM7xNYrVWX+KcA=="
+    },
     "util": {
       "version": "0.11.1",
       "resolved": "https://registry.npmjs.org/util/-/util-0.11.1.tgz",
Index: src/alphabet.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/alphabet.ts b/src/alphabet.ts
new file mode 100644
--- /dev/null	(date 1612022975958)
+++ b/src/alphabet.ts	(date 1612022975958)
@@ -0,0 +1,3 @@
+import {OrderedSet} from "immutable";
+
+export type Alphabet = OrderedSet<string>;
Index: src/App.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/App.js b/src/App.tsx
rename from src/App.js
rename to src/App.tsx
--- a/src/App.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/App.tsx	(date 1612022976006)
@@ -5,15 +5,16 @@
 import Container from "@material-ui/core/Container";
 import View from "./View";
 import Input from "./Input";
-import {List, Map, Record} from "immutable";
+import {List, Map} from "immutable";
 import Snackbar from "@material-ui/core/Snackbar";
 import Button from "@material-ui/core/Button";
 import IconButton from "@material-ui/core/IconButton";
-import {makeStyles} from "@material-ui/core/styles";
+import {makeStyles, Theme} from "@material-ui/core/styles";
 import CloseIcon from "@material-ui/icons/Close";
-import {v4 as uuidv4} from "uuid";
+import {SnackbarMessage, SnackbarMessageRecord} from "./snackbarMessage";
+import Automaton from "./automaton";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   close: {
     padding: theme.spacing(0.5),
   },
@@ -22,10 +23,10 @@
 export default function App() {
   const classes = useStyles();
 
-  const [automata, setAutomata] = React.useState(List());
-  const [snackbarQueue, setSnackbarQueue] = React.useState(List());
+  const [automata, setAutomata] = React.useState(List<Automaton>());
+  const [snackbarQueue, setSnackbarQueue] = React.useState(List<SnackbarMessage>());
   const [snackbarOpen, setSnackbarOpen] = React.useState(false);
-  const [snackbar, setSnackbar] = React.useState(undefined);
+  const [snackbar, setSnackbar] = React.useState<SnackbarMessage | null>(null);
 
   const messages = Map({
     automatonAdded: "Automaton created",
@@ -33,7 +34,7 @@
     stateDeleted: "State deleted",
   });
 
-  React.useEffect(() => {
+  React.useEffect((): void => {
     if (!snackbarQueue.isEmpty() && !snackbar) {
       // Set a new snack when we don't have an active one
       setSnackbar(snackbarQueue.first());
@@ -45,18 +46,13 @@
     }
   }, [snackbarQueue, snackbar, snackbarOpen]);
 
-  const SnackbarMessage = Record({
-    id: uuidv4(),
-    message: "",
-  });
-
-  const handleSnackbarOpen = key => () => {
-    setSnackbarQueue(prevSnackPack => prevSnackPack.push(SnackbarMessage({
+  const handleSnackbarOpen = (key: string) => (): void => {
+    setSnackbarQueue(prevSnackPack => prevSnackPack.push(SnackbarMessageRecord({
       message: messages.get(key),
     })));
   };
 
-  const handleSnackbarClose = (event, reason) => {
+  const handleSnackbarClose = (event: object | React.MouseEvent<HTMLButtonElement, MouseEvent>, reason?: string): void => {
     if (reason === "clickaway") {
       return;
     }
@@ -64,11 +60,11 @@
     setSnackbarOpen(false);
   };
 
-  const handleSnackbarExited = () => {
-    setSnackbar(undefined);
+  const handleSnackbarExited = (): void => {
+    setSnackbar(null);
   };
 
-  const addAutomaton = automaton => setAutomata(prevAutomata => prevAutomata.push(automaton));
+  const addAutomaton = (automaton: Automaton): void => setAutomata(prevAutomata => prevAutomata.push(automaton));
 
   return (
     <Router>
@@ -90,12 +86,12 @@
           </Route>
         </Switch>
         <Snackbar
-          key={snackbar ? snackbar.key : undefined}
+          key={snackbar ? snackbar.id : null}
           open={snackbarOpen}
           autoHideDuration={6000}
           onClose={handleSnackbarClose}
           onExited={handleSnackbarExited}
-          message={snackbar ? snackbar.message : undefined}
+          message={snackbar ? snackbar.message : null}
           action={
             <React.Fragment>
               <Button color="secondary" size="small" onClick={handleSnackbarClose}>
Index: src/StatesInput.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/StatesInput.js b/src/StatesInput.tsx
rename from src/StatesInput.js
rename to src/StatesInput.tsx
--- a/src/StatesInput.js	(revision 42f46666662190f022ab8739d3fff76c4a2c77b8)
+++ b/src/StatesInput.tsx	(date 1612044988435)
@@ -1,6 +1,5 @@
-import React from "react";
-import {Record} from "immutable";
-import {makeStyles} from "@material-ui/core/styles";
+import React, {Dispatch, ReducerAction, SetStateAction} from "react";
+import {makeStyles, Theme} from "@material-ui/core/styles";
 import TextField from "@material-ui/core/TextField";
 import FormControlLabel from "@material-ui/core/FormControlLabel";
 import Radio from "@material-ui/core/Radio";
@@ -11,9 +10,11 @@
 import Button from "@material-ui/core/Button";
 import Alert from "@material-ui/lab/Alert";
 import AlertTitle from "@material-ui/lab/AlertTitle";
-import {v4 as uuidv4} from "uuid";
+import State from "./state";
+import {StatesErrorState, StatesHelperText} from "./validation";
+import {Action} from "./Input";
 
-const useStyles = makeStyles((theme) => ({
+const useStyles = makeStyles((theme: Theme) => ({
   root: {
     '& > *': {
       margin: theme.spacing(1),
@@ -26,71 +27,56 @@
   },
 }));
 
+type StatesInputProps = {
+  states: State[];
+  initialStateId: string;
+  finalStateIds: string[];
+  errorState: StatesErrorState;
+  helperText: StatesHelperText;
+  errorAlertText: string[];
+  warningAlertText: string[];
+  onAddState: () => void;
+  onRemoveState: (index: number) => void;
+  onSetStateName: (index: number, name: string) => void;
+  onSetInitialStateId: (id: string) => void;
+  onSetFinalStateIds: (id: string, isFinal: boolean) => void;
+};
+
 export default function StatesInput({
                                       states,
-                                      onStatesChange,
                                       initialStateId,
-                                      onInitialStateIdChange,
                                       finalStateIds,
-                                      onFinalStateIdsChange,
                                       errorState,
                                       helperText,
                                       errorAlertText,
                                       warningAlertText,
-                                    }) {
+                                      onAddState,
+                                      onRemoveState,
+                                      onSetStateName,
+                                      onSetInitialStateId,
+                                      onSetFinalStateIds,
+                                    }: StatesInputProps) {
   const classes = useStyles();
 
-  const State = Record({
-    id: uuidv4(),
-    name: "",
-  });
-
-  const handleAddStateClick = () => {
-    onStatesChange(prevStates => prevStates.push(State()));
-  };
-
-  const handleRemoveStateClick = index => {
-    onStatesChange(prevStates => prevStates.delete(index));
-  };
-
-  const handleNameChange = (event, index) => {
-    const updatedName = event.target.value;
-    onStatesChange(prevStates => prevStates.setIn([index, "name"], updatedName));
-  };
-
-  const handleInitialStateIdChange = event => {
-    const updatedInitialStateId = event.target.value;
-    onInitialStateIdChange(updatedInitialStateId);
-  };
-
-  const handleFinalStateIdsChange = (event, state) => {
-    const isFinal = event.target.checked;
-    if (isFinal) {
-      onFinalStateIdsChange(prevFinalStateIds => prevFinalStateIds.add(state.get("id")));
-    } else {
-      onFinalStateIdsChange(prevFinalStateIds => prevFinalStateIds.delete(state.get("id")));
-    }
-  };
-
   return (
     <>
       <form className={classes.root} autoComplete="off">
-        {states.map((state, index) => (
+        {states.map((state: State, index: number) => (
           <React.Fragment key={index}>
             <TextField
               id={`state-name-${index + 1}`}
               label={`State ${index + 1} name`}
-              value={state.get("name")}
-              onChange={event => handleNameChange(event, index)}
-              error={errorState.getIn(["stateName", index])}
-              helperText={helperText.getIn(["stateName", index])}
+              value={state.name}
+              onChange={event => onSetStateName(index, event.target.value)}
+              error={errorState.stateName.get(index)}
+              helperText={helperText.stateName.get(index)}
             />
             <FormControlLabel
               control={
                 <Radio
-                  checked={initialStateId === state.get("id")}
-                  value={state.get("id")}
-                  onChange={event => handleInitialStateIdChange(event)}
+                  checked={initialStateId === state.id}
+                  value={state.id}
+                  onChange={event => onSetInitialStateId(event.target.value)}
                 />
               }
               label="Initial"
@@ -98,37 +84,37 @@
             <FormControlLabel
               control={
                 <Checkbox
-                  checked={finalStateIds.includes(state.get("id"))}
-                  onChange={event => handleFinalStateIdsChange(event, state)}
+                  checked={finalStateIds.includes(state.id)}
+                  onChange={event => onSetFinalStateIds(state.id, event.target.checked)}
                   name={`state-${index + 1}-final`}
                 />
               }
               label="Final"
             />
             <Tooltip title={`Delete State ${index + 1}`}>
-              <IconButton onClick={() => handleRemoveStateClick(index)} aria-label="delete">
+              <IconButton onClick={() => onRemoveState(index)} aria-label="delete">
                 <DeleteIcon/>
               </IconButton>
             </Tooltip>
           </React.Fragment>
         ))}
-        <Button onClick={handleAddStateClick} variant="contained">Add state</Button>
+        <Button onClick={onAddState} variant="contained">Add state</Button>
       </form>
-      {errorAlertText.isEmpty() || (
+      {errorAlertText && (
         <Alert severity="error">
-          <AlertTitle>{errorAlertText.count() === 1 ? "Error" : "Errors"}</AlertTitle>
+          <AlertTitle>{errorAlertText.length === 1 ? "Error" : "Errors"}</AlertTitle>
           <ul>
-            {errorAlertText.map((message, index) => (
+            {errorAlertText.map((message: string, index: number) => (
               <li key={index}>{message}</li>
             ))}
           </ul>
         </Alert>
       )}
-      {warningAlertText.isEmpty() || (
+      {warningAlertText && (
         <Alert severity="warning">
-          <AlertTitle>{warningAlertText.count() === 1 ? "Warning" : "Warnings"}</AlertTitle>
+          <AlertTitle>{warningAlertText.length === 1 ? "Warning" : "Warnings"}</AlertTitle>
           <ul>
-            {warningAlertText.map((message, index) => (
+            {warningAlertText.map((message: string, index) => (
               <li key={index}>{message}</li>
             ))}
           </ul>
Index: src/Input.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Input.tsx b/src/Input.tsx
new file mode 100644
--- /dev/null	(date 1612047454000)
+++ b/src/Input.tsx	(date 1612047454000)
@@ -0,0 +1,306 @@
+import React from 'react';
+import AlphabetInput from "./AlphabetInput";
+import StatesInput from "./StatesInput";
+import TransitionsInput from "./TransitionsInput";
+import {makeStyles, Theme} from "@material-ui/core/styles";
+import Button from "@material-ui/core/Button";
+import Typography from "@material-ui/core/Typography";
+import Step from "@material-ui/core/Step";
+import StepButton from "@material-ui/core/StepButton";
+import Stepper from "@material-ui/core/Stepper";
+import {useHistory} from "react-router-dom";
+import {StepLabel} from "@material-ui/core";
+import {NIL, v4 as uuidv4} from "uuid";
+import Automaton from "./automaton";
+import State from "./state";
+import {Transition} from "./transition";
+import {AlphabetErrorState, StatesErrorState, TransitionsErrorState, validate} from "./validation";
+import _ from "lodash";
+import {useImmerReducer} from "use-immer";
+import * as R from "ramda";
+
+const useStyles = makeStyles((theme: Theme) => ({
+  root: {
+    width: '100%',
+  },
+  button: {
+    marginRight: theme.spacing(1),
+  },
+  backButton: {
+    marginRight: theme.spacing(1),
+  },
+  completed: {
+    display: 'inline-block',
+  },
+  instructions: {
+    marginTop: theme.spacing(1),
+    marginBottom: theme.spacing(1),
+  },
+}));
+
+type InputProps = {
+  addAutomaton: (automaton: Automaton) => void;
+  openSnackbar: () => void;
+};
+
+type InputState = {
+  alphabet: string[];
+  alphabetPresetIndex: number | "";
+  states: State[];
+  transitions: Transition[];
+  initialStateId: string;
+  finalStateIds: string[];
+};
+
+export type Action =
+  | { type: "addState" }
+  | { type: "removeState", index: number }
+  | { type: "setStateName", index: number, name: string }
+  | { type: "setInitialStateId", id: string }
+  | { type: "setFinalStateIds", id: string, isFinal: boolean }
+  | { type: "addTransition" }
+  | { type: "removeTransition", index: number }
+  | { type: "currentStateChange", index: number, stateId: string }
+  | { type: "symbolChange", index: number, symbol: string }
+  | { type: "nextStatesChange", index: number, stateId: string };
+
+const initialState: InputState = {
+  alphabet: [],
+  alphabetPresetIndex: "",
+  states: [],
+  transitions: [],
+  initialStateId: NIL,
+  finalStateIds: [],
+};
+
+function reducer(draft: InputState, action: Action) {
+  switch (action.type) {
+    case "addState":
+      draft.states = R.append({
+        id: uuidv4(),
+        name: "",
+      }, draft.states);
+      return;
+    case "removeState":
+      draft.states = R.remove(action.index, 1, draft.states);
+      return;
+    case "setStateName":
+      draft.states[action.index].name = action.name;
+      return;
+    case "setInitialStateId":
+      draft.initialStateId = action.id;
+      return;
+    case "setFinalStateIds":
+      draft.finalStateIds = action.isFinal ? R.union(draft.finalStateIds, [action.id]) : R.difference(draft.finalStateIds, [action.id]);
+      return;
+    case "addTransition":
+      draft.transitions = R.append({
+        currentState: "",
+        symbol: "",
+        nextStates: Set(),
+      }, draft.transitions);
+      return;
+    case "removeTransition":
+      draft.transitions = R.remove(action.index, 1, draft.transitions);
+      return;
+    case "currentStateChange":
+      draft.transitions[action.index] = action.stateId;
+      return;
+    case "symbolChange":
+      draft.transitions[action.index] = action.symbol;
+      return;
+    case "nextStatesChange":
+      draft.transitions[action.index] = action.stateId;
+      return;
+  }
+}
+
+export default function Input({addAutomaton, openSnackbar}: InputProps) {
+  const classes = useStyles();
+
+  const history = useHistory();
+
+  const [state, dispatch] = useImmerReducer(reducer, initialState);
+  // const [alphabet, setAlphabet] = useImmerReducer()
+  const [alphabetPresetIndex, setAlphabetPresetIndex] = React.useState<number | "">("");
+  const [states, setStates] = React.useState(List<State>());
+  const [initialStateId, setInitialStateId] = React.useState(NIL);
+  const [finalStateIds, setFinalStateIds] = React.useState(OrderedSet<string>()); // TODO: Doesn't need to be ordered (I think)
+  const [transitions, setTransitions] = React.useState(List<Transition>());
+
+  const stateIds = states.map(state => state.get("id")).toSet();
+
+  const {errorState, helperText, errorAlertText, warningAlertText} = validate(alphabet, states, transitions, initialStateId, finalStateIds);
+
+  const fixInitialStateId = (): void => {
+    setInitialStateId(prevInitialStateId => stateIds.includes(prevInitialStateId) ? prevInitialStateId : NIL);
+  };
+
+  const fixFinalStateIds = (): void => {
+    setFinalStateIds(prevFinalStateIds => prevFinalStateIds.intersect(stateIds));
+  };
+
+  const fixTransitionCurrentStates = (): void => {
+    setTransitions(prevTransitions => prevTransitions.map(transition =>
+      transition.update("currentState", currentState => stateIds.includes(currentState) ? currentState : "")
+    ));
+  };
+
+  const fixTransitionSymbol = (): void => {
+    setTransitions(prevTransitions => prevTransitions.map(transition =>
+      transition.update("symbol", symbol => alphabet.includes(symbol) ? symbol : "")
+    ));
+  };
+
+  const fixTransitionNextStates = (): void => {
+    setTransitions(prevTransitions => prevTransitions.map(transition =>
+      transition.update("nextStates", nextStates => nextStates.intersect(stateIds))
+    ));
+  };
+
+  React.useEffect(fixInitialStateId, [stateIds]);
+  React.useEffect(fixTransitionSymbol, [alphabet]);
+  React.useEffect(fixFinalStateIds, [stateIds]);
+  React.useEffect(fixTransitionCurrentStates, [stateIds]);
+  React.useEffect(fixTransitionNextStates, [stateIds]);
+
+  const stepContent = [
+    <AlphabetInput
+      alphabet={alphabet}
+      onAlphabetChange={setAlphabet}
+      alphabetPresetIndex={alphabetPresetIndex}
+      onAlphabetPresetIndexChange={setAlphabetPresetIndex}
+      errorState={errorState.alphabet}
+      helperText={helperText.alphabet}
+    />,
+    <StatesInput
+      states={states}
+      initialStateId={initialStateId}
+      finalStateIds={finalStateIds}
+      errorState={errorState.states}
+      helperText={helperText.states}
+      errorAlertText={errorAlertText.states}
+      warningAlertText={warningAlertText.states}
+      onAddState={() => dispatch({ type: "addState" })}
+      onRemoveState={(index) => dispatch({ type: "removeState", index })}
+      onSetStateName={(index, name) => dispatch({ type: "setStateName", index, name })}
+      onSetInitialStateId={(id) => dispatch({ type: "setInitialStateId", id })}
+      onSetFinalStateIds={(id, isFinal) => dispatch({ type: "setFinalStateIds", id, isFinal })}
+    />,
+    <TransitionsInput
+      transitions={transitions}
+      alphabet={alphabet}
+      states={states}
+      errorState={errorState.transitions}
+      helperText={helperText.transitions}
+      warningAlertText={warningAlertText.transitions}
+      onAddTransition={() => dispatch({ type: "addTransition" })}
+      onRemoveState={(index) => dispatch({ type: "removeTransition", index })}
+      onCurrentStateChange={(index, stateId) => dispatch({ type: "currentStateChange", index, stateId })}
+      onSymbolChange={(index, symbol) => dispatch({ type: "symbolChange", index, symbol })}
+      onNextStatesChange={(index, stateId) => dispatch({ type: "nextStatesChange", index, stateId })}
+    />,
+  ];
+
+  // TODO: Maybe find a better way of doing this
+  // TODO: In validation, use boolean[] instead of List<boolean> (so code below works)
+  const countErrors = (errorState: AlphabetErrorState | StatesErrorState | TransitionsErrorState,
+                       errorAlertText: string[]): number => {
+    return _.chain(errorState).values().flatten().map(x => x === true).size() + errorAlertText.length;
+  };
+
+  interface Step {
+    label: string;
+    completed: boolean;
+    errorCount: number;
+    warningCount: number;
+  }
+
+  const steps: Step[] = [
+    {
+      label: "Specify alphabet",
+      completed: countErrors(errorState.alphabet, errorAlertText.alphabet) === 0,
+      errorCount: .,
+      warningCount: 0,
+    },
+    {
+      label: "Specify states",
+      completed: countErrors("states") === 0,
+      errorCount: countErrors("states"),
+      warningCount: warningAlertText.states.length,
+    },
+    {
+      label: "Specify transitions",
+      completed: countErrors("transitions") === 0,
+      errorCount: countErrors("transitions"),
+      warningCount: warningAlertText.transitions.length,
+    },
+  ];
+  const [activeStepIndex, setActiveStepIndex] = React.useState(0);
+
+  const allStepsCompleted = (): boolean => steps.every(step => step.completed);
+
+  const handleNext = (): void => {
+    const updatedActiveStepIndex =
+      activeStepIndex === steps.length - 1 && !allStepsCompleted()
+        ? // It's the last step, but not all steps have been completed
+          // find the first step that has not been completed
+        steps.findIndex(step => !step.completed)
+        : activeStepIndex + 1;
+
+    setActiveStepIndex(updatedActiveStepIndex);
+  };
+
+  const handleBack = (): void => setActiveStepIndex(prevActiveStep => prevActiveStep - 1);
+
+  const handleStep = (stepIndex: number) => (): void => setActiveStepIndex(stepIndex);
+
+  const handleFinish = (): void => {
+    let automaton = Automaton.createAutomaton(alphabet, states, transitions, initialStateId, finalStateIds);
+    addAutomaton(automaton);
+    history.push("/");
+    openSnackbar();
+  };
+
+  return (
+    <div className={classes.root}>
+      <Stepper alternativeLabel nonLinear activeStep={activeStepIndex} style={{backgroundColor: "transparent"}}>
+        {steps.map((step, index) => (
+          <Step key={index}>
+            <StepButton
+              onClick={handleStep(index)}
+              completed={step.completed}
+              optional={(step.errorCount && (
+                <Typography variant="caption" color="error">
+                  {step.errorCount} {step.errorCount === 1 ? "error" : "errors"}
+                </Typography>
+              )) || (step.warningCount && (
+                <Typography variant="caption">
+                  {step.warningCount} {step.warningCount === 1 ? "warning" : "warnings"}
+                </Typography>
+              ))}
+            >
+              <StepLabel error={step.errorCount > 0}>{step.label}</StepLabel>
+            </StepButton>
+          </Step>
+        ))}
+      </Stepper>
+      {stepContent[activeStepIndex]}
+      <Button disabled={activeStepIndex === 0} onClick={handleBack} className={classes.button}>
+        Back
+      </Button>
+      <Button
+        variant="contained"
+        color="primary"
+        onClick={handleNext}
+        className={classes.button}
+        disabled={activeStepIndex === steps.length - 1 && allStepsCompleted()}
+      >
+        Next
+      </Button>
+      <Button variant="contained" color="primary" onClick={handleFinish} disabled={!allStepsCompleted()}>
+        Finish
+      </Button>
+    </div>
+  );
+}
diff --git a/src/View.js b/src/View.tsx
rename from src/View.js
rename to src/View.tsx
